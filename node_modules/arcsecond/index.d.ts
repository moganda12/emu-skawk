declare const encoder: TextEncoder;
declare const decoder: TextDecoder;
declare const getString: (index: number, length: number, dataView: DataView) => string;
declare const getNextCharWidth: (index: number, dataView: DataView) => 1 | 2 | 3 | 4;
declare const getUtf8Char: (index: number, length: number, dataView: DataView) => string;
declare const getCharacterLength: (str: string) => number;

declare type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;
declare type InputType = string | ArrayBuffer | DataView | TypedArray;
declare enum InputTypes {
    STRING = "string",
    ARRAY_BUFFER = "arrayBuffer",
    TYPED_ARRAY = "typedArray",
    DATA_VIEW = "dataView"
}

declare const updateError: <T, E, D, E2>(state: ParserState<T, E, D>, error: E2) => ParserState<T, E2, D>;
declare const updateResult: <T, E, D, T2>(state: ParserState<T, E, D>, result: T2) => ParserState<T2, E, D>;
declare const updateData: <T, E, D, D2>(state: ParserState<T, E, D>, data: D2) => ParserState<T, E, D2>;
declare const updateParserState: <T, E, D, T2>(state: ParserState<T, E, D>, result: T2, index: number) => ParserState<T2, E, D>;
declare type StateTransformerFunction<T, E = any, D = any> = (state: ParserState<any, any, any>) => ParserState<T, E, D>;
declare type ParserState<T, E, D> = {
    dataView: DataView;
    inputType: InputType;
} & InternalResultType<T, E, D>;
declare type InternalResultType<T, E, D> = {
    isError: boolean;
    error: E;
    index: number;
    result: T;
    data: D;
};
declare type ResultType<T, E, D> = Err<E, D> | Ok<T, D>;
declare type Err<E, D> = {
    isError: true;
    error: E;
    index: number;
    data: D;
};
declare type Ok<T, D> = {
    isError: false;
    index: number;
    result: T;
    data: D;
};
declare class Parser<T, E = string, D = any> {
    p: StateTransformerFunction<T, E, D>;
    constructor(p: StateTransformerFunction<T, E, D>);
    run(target: InputType): ResultType<T, E, D>;
    fork<F>(target: InputType, errorFn: (errorMsg: E, parsingState: ParserState<T, E, D>) => F, successFn: (result: T, parsingState: ParserState<T, E, D>) => F): F;
    map<T2>(fn: (x: T) => T2): Parser<T2, E, D>;
    chain<T2>(fn: (x?: T) => Parser<T2, E, D>): Parser<T2, E, D>;
    ap<T2>(parserOfFunction: Parser<(x: T) => T2, E, D>): Parser<T2, E, D>;
    errorMap<E2>(fn: (error: Err<E, D>) => E2): Parser<T, E2, D>;
    errorChain<T2, E2>(fn: (error: Err<E, D>) => Parser<T2, E2, D>): Parser<T2, E2, D>;
    mapFromData<T2>(fn: (data: Ok<T, D>) => T2): Parser<T2, E, D>;
    chainFromData<T2, E2>(fn: (data: {
        result: T;
        data: D;
    }) => Parser<T2, E2, D>): Parser<T2, E2, D>;
    mapData<D2>(fn: (data: D) => D2): Parser<T, E, D2>;
    static of<T, E = any, D = null>(x: T): Parser<T, E, D>;
}

declare const getData: Parser<any, any, any>;
declare function setData<T, E, D2>(data: D2): Parser<T, E, D2>;
declare function mapData<T, E, D2>(fn: (data: any) => D2): Parser<T, E, D2>;
declare function withData<T, E, D>(parser: Parser<T, E, any>): (data: D) => Parser<T, E, D>;
declare function pipeParsers<A>([p1]: [Parser<A>]): Parser<A>;
declare function pipeParsers<A, B>([p1, p2]: [Parser<A>, Parser<B>]): Parser<B>;
declare function pipeParsers<A, B, C>([p1, p2, p3]: [Parser<A>, Parser<B>, Parser<C>]): Parser<C>;
declare function pipeParsers<A, B, C, D>([p1, p2, p3, p4]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>]): Parser<D>;
declare function pipeParsers<A, B, C, D, E>([p1, p2, p3, p4, p5]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>]): Parser<E>;
declare function pipeParsers<A, B, C, D, E, F>([p1, p2, p3, p4, p5, p6]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>]): Parser<F>;
declare function pipeParsers<A, B, C, D, E, F, G>([p1, p2, p3, p4, p5, p6, p7]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>]): Parser<G>;
declare function pipeParsers<A, B, C, D, E, F, G, H>([p1, p2, p3, p4, p5, p6, p7, p8]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>]): Parser<H>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I>([p1, p2, p3, p4, p5, p6, p7, p8, p9]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>]): Parser<I>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I, J>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>]): Parser<J>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I, J, K>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>]): Parser<K>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I, J, K, L>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>]): Parser<L>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I, J, K, L, M>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>]): Parser<M>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I, J, K, L, M, N>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>]): Parser<N>;
declare function pipeParsers<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>, Parser<O>]): Parser<O>;
declare function pipeParsers(parsers: Parser<any>[]): Parser<any>;
declare function composeParsers<A, B>([p1, p2]: [Parser<A>, Parser<B>]): Parser<A>;
declare function composeParsers<A, B, C>([p1, p2, p3]: [Parser<A>, Parser<B>, Parser<C>]): Parser<A>;
declare function composeParsers<A, B, C, D>([p1, p2, p3, p4]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>]): Parser<A>;
declare function composeParsers<A, B, C, D, E>([p1, p2, p3, p4, p5]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F>([p1, p2, p3, p4, p5, p6]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G>([p1, p2, p3, p4, p5, p6, p7]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H>([p1, p2, p3, p4, p5, p6, p7, p8]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I>([p1, p2, p3, p4, p5, p6, p7, p8, p9]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I, J>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I, J, K>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I, J, K, L>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I, J, K, L, M>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I, J, K, L, M, N>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>]): Parser<A>;
declare function composeParsers<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>, Parser<O>]): Parser<A>;
declare function composeParsers(parsers: Parser<any>[]): Parser<any>;
declare function tapParser<T, E, D>(fn: (state: ParserState<T, E, D>) => void): Parser<T, E, D>;
declare function parse<T, E, D>(parser: Parser<T, E, D>): (target: InputType) => ResultType<T, E, D>;
declare function decide<T, T2, E2, D2>(fn: (value: T) => Parser<T2, E2, D2>): Parser<T2, E2, D2>;
declare function fail<E, D>(errorMessage: E): Parser<any, E, D>;
declare const succeedWith: typeof Parser.of;
declare function either<T>(parser: Parser<T>): Parser<{
    isError: boolean;
    value: T;
}>;
declare type ParserFn<T> = (_yield: <K>(parser: Parser<K>) => K) => T;
declare function coroutine<T>(parserFn: ParserFn<T>): Parser<T>;
declare function exactly<T, N extends 1>(n: N): (p: Parser<T>) => Parser<[T]>;
declare function exactly<T, N extends 2>(n: N): (p: Parser<T>) => Parser<[T, T]>;
declare function exactly<T, N extends 3>(n: N): (p: Parser<T>) => Parser<[T, T, T]>;
declare function exactly<T, N extends 4>(n: N): (p: Parser<T>) => Parser<[T, T, T, T]>;
declare function exactly<T, N extends 5>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T]>;
declare function exactly<T, N extends 6>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T]>;
declare function exactly<T, N extends 7>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 8>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 9>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 10>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 11>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 12>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 13>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 14>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T, T, T, T, T, T]>;
declare function exactly<T, N extends 15>(n: N): (p: Parser<T>) => Parser<[T, T, T, T, T, T, T, T, T, T, T, T, T, T, T]>;
declare function exactly<T>(n: number): (p: Parser<T>) => Parser<T[]>;
declare const many: <T>(parser: Parser<T, string, any>) => Parser<T[], string, any>;
declare const many1: <T>(parser: Parser<T, string, any>) => Parser<T[], string, any>;
declare function mapTo<T>(fn: (x: any) => T): Parser<T>;
declare function errorMapTo<E, E2, D>(fn: (error: E, index: number, data: D) => E2): Parser<any, E, D>;
declare const char: (c: string) => Parser<string>;
declare const anyChar: Parser<string>;
declare const peek: Parser<number>;
declare function str(s: string): Parser<string>;
declare function regex(re: RegExp): Parser<string>;
declare const digit: Parser<string>;
declare const digits: Parser<string>;
declare const letter: Parser<string>;
declare const letters: Parser<string>;
declare function anyOfString(s: string): Parser<string>;
declare function namedSequenceOf(pairedParsers: Array<[string, Parser<any>]>): Parser<any[]>;
declare function sequenceOf<A>([p1]: [Parser<A>]): Parser<[A]>;
declare function sequenceOf<A, B>([p1, p2]: [Parser<A>, Parser<B>]): Parser<[A, B]>;
declare function sequenceOf<A, B, C>([p1, p2, p3]: [Parser<A>, Parser<B>, Parser<C>]): Parser<[A, B, C]>;
declare function sequenceOf<A, B, C, D>([p1, p2, p3, p4]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>]): Parser<[A, B, C, D]>;
declare function sequenceOf<A, B, C, D, E>([p1, p2, p3, p4, p5]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>]): Parser<[A, B, C, D, E]>;
declare function sequenceOf<A, B, C, D, E, F>([p1, p2, p3, p4, p5, p6]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>]): Parser<[A, B, C, D, E, F]>;
declare function sequenceOf<A, B, C, D, E, F, G>([p1, p2, p3, p4, p5, p6, p7]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>]): Parser<[A, B, C, D, E, F, G]>;
declare function sequenceOf<A, B, C, D, E, F, G, H>([p1, p2, p3, p4, p5, p6, p7, p8]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>]): Parser<[A, B, C, D, E, F, G, H]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I>([p1, p2, p3, p4, p5, p6, p7, p8, p9]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>]): Parser<[A, B, C, D, E, F, G, H, I]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I, J>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>]): Parser<[A, B, C, D, E, F, G, H, I, J]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I, J, K>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>]): Parser<[A, B, C, D, E, F, G, H, I, J, K]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I, J, K, L>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>]): Parser<[A, B, C, D, E, F, G, H, I, J, K, L]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I, J, K, L, M>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>]): Parser<[A, B, C, D, E, F, G, H, I, J, K, L, M]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I, J, K, L, M, N>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>]): Parser<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>;
declare function sequenceOf<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>, Parser<O>]): Parser<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>;
declare function sequenceOf(parsers: Parser<any>[]): Parser<any[]>;
declare function sepBy<S, T, E, D>(sepParser: Parser<S, E, D>): (valueParser: Parser<T, E, D>) => Parser<T[]>;
declare const sepBy1: <S, T>(sepParser: Parser<S, string, any>) => (valueParser: Parser<T, string, any>) => Parser<T[], string, any>;
declare function choice<A>([p1]: [Parser<A>]): Parser<A>;
declare function choice<A, B>([p1, p2]: [Parser<A>, Parser<B>]): Parser<A | B>;
declare function choice<A, B, C>([p1, p2, p3]: [Parser<A>, Parser<B>, Parser<C>]): Parser<A | B | C>;
declare function choice<A, B, C, D>([p1, p2, p3, p4]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>]): Parser<A | B | C | D>;
declare function choice<A, B, C, D, E>([p1, p2, p3, p4, p5]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>]): Parser<A | B | C | D | E>;
declare function choice<A, B, C, D, E, F>([p1, p2, p3, p4, p5, p6]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>]): Parser<A | B | C | D | E | F>;
declare function choice<A, B, C, D, E, F, G>([p1, p2, p3, p4, p5, p6, p7]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>]): Parser<A | B | C | D | E | F | G>;
declare function choice<A, B, C, D, E, F, G, H>([p1, p2, p3, p4, p5, p6, p7, p8]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>]): Parser<A | B | C | D | E | F | G | H>;
declare function choice<A, B, C, D, E, F, G, H, I>([p1, p2, p3, p4, p5, p6, p7, p8, p9]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>]): Parser<A | B | C | D | E | F | G | H | I>;
declare function choice<A, B, C, D, E, F, G, H, I, J>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>]): Parser<A | B | C | D | E | F | G | H | I | J>;
declare function choice<A, B, C, D, E, F, G, H, I, J, K>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>]): Parser<A | B | C | D | E | F | G | H | I | J | K>;
declare function choice<A, B, C, D, E, F, G, H, I, J, K, L>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>]): Parser<A | B | C | D | E | F | G | H | I | J | K | L>;
declare function choice<A, B, C, D, E, F, G, H, I, J, K, L, M>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>]): Parser<A | B | C | D | E | F | G | H | I | J | K | L | M>;
declare function choice<A, B, C, D, E, F, G, H, I, J, K, L, M, N>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>]): Parser<A | B | C | D | E | F | G | H | I | J | K | L | M | N>;
declare function choice<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15]: [Parser<A>, Parser<B>, Parser<C>, Parser<D>, Parser<E>, Parser<F>, Parser<G>, Parser<H>, Parser<I>, Parser<J>, Parser<K>, Parser<L>, Parser<M>, Parser<N>, Parser<O>]): Parser<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O>;
declare function choice(parsers: Parser<any>[]): Parser<any>;
declare function between<L, T, R>(leftParser: Parser<L>): (rightParser: Parser<R>) => (parser: Parser<T>) => Parser<T>;
declare function everythingUntil(parser: Parser<any>): Parser<number[]>;
declare const everyCharUntil: (parser: Parser<any>) => Parser<string, string, any>;
declare const anythingExcept: (parser: Parser<any>) => Parser<number>;
declare const anyCharExcept: (parser: Parser<any>) => Parser<number>;
declare function lookAhead<T, E, D>(parser: Parser<T, E, D>): Parser<T, E, D>;
declare function possibly<T, E, D>(parser: Parser<T, E, D>): Parser<T | null, E, D>;
declare function skip<E, D>(parser: Parser<any, E, D>): Parser<null, E, D>;
declare const startOfInput: Parser<null, string, any>;
declare const endOfInput: Parser<null, string, any>;
declare const whitespace: Parser<string>;
declare const optionalWhitespace: Parser<string | null>;
declare function recursiveParser<T, E, D>(parserThunk: () => Parser<T, E, D>): Parser<T, E, D>;
declare function takeRight<L, R>(leftParser: Parser<L>): (rightParser: Parser<R>) => Parser<R, string, any>;
declare const takeLeft: <L, R>(leftParser: Parser<L, string, any>) => (rightParser: Parser<R, string, any>) => Parser<L | undefined, string, any>;
declare function toPromise<T, E, D>(result: ResultType<T, E, D>): Promise<T>;
declare function toValue<T, E, D>(result: ResultType<T, E, D>): T;

export { Err, InputType, InputTypes, Ok, Parser, ParserState, ResultType, anyChar, anyCharExcept, anyOfString, anythingExcept, between, char, choice, composeParsers, coroutine, decide, decoder, digit, digits, either, encoder, endOfInput, errorMapTo, everyCharUntil, everythingUntil, exactly, fail, getCharacterLength, getData, getNextCharWidth, getString, getUtf8Char, letter, letters, lookAhead, many, many1, mapData, mapTo, namedSequenceOf, optionalWhitespace, parse, peek, pipeParsers, possibly, recursiveParser, regex, sepBy, sepBy1, sequenceOf, setData, skip, startOfInput, str, succeedWith, takeLeft, takeRight, tapParser, toPromise, toValue, updateData, updateError, updateParserState, updateResult, whitespace, withData };
